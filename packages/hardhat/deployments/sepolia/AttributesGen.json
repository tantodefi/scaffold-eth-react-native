{
  "address": "0x14C37E3018aA72A788d904604dB105Ff8d307f5E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "min",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "max",
          "type": "uint256"
        }
      ],
      "name": "PRNG__InvalidRange",
      "type": "error"
    }
  ],
  "transactionHash": "0x2b5231a5c80aa5cd3bd7a224dba0ed29b54e918cf9ef827c72ec8870b5822698",
  "receipt": {
    "to": null,
    "from": "0x7a82bbfD10E3Ce5817dEcC0ee870e17D6853D901",
    "contractAddress": "0x14C37E3018aA72A788d904604dB105Ff8d307f5E",
    "transactionIndex": 31,
    "gasUsed": "601902",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf99d69bb957bc73a6e5f05dfdb9312898b8eab1166b5b6e27ffea09a1c88fc96",
    "transactionHash": "0x2b5231a5c80aa5cd3bd7a224dba0ed29b54e918cf9ef827c72ec8870b5822698",
    "logs": [],
    "blockNumber": 5668177,
    "cumulativeGasUsed": "5370444",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "b96a574724eef3f8c3d467b0f1e28008",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"PRNG__InvalidRange\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/logic/AttributesGen.sol\":\"AttributesGen\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/libraries/logic/AttributesGen.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {DataTypes} from \\\"../types/DataTypes.sol\\\";\\nimport {ColorGen} from \\\"../utils/ColorGen.sol\\\";\\nimport {PRNG} from \\\"../utils/PRNG.sol\\\";\\n\\nlibrary AttributesGen {\\n  function generateAttributes(mapping(uint256 => DataTypes.Snowman) storage s_attributes, uint256 tokenId) external {\\n    DataTypes.Snowman memory snowman;\\n    string[2] memory colors;\\n\\n    // generate random cloud and button color\\n    for (uint256 i = 0; i < 2; i++) {\\n      colors[i] = ColorGen.HSLA(bytes32(i));\\n    }\\n\\n    snowman = DataTypes.Snowman({\\n      eyeOffsetX: int256(PRNG.range(0, 19, keccak256(\\\"1\\\"))) - 9, // range: -9 - 9\\n      eyeOffsetY: int256(PRNG.range(0, 19, keccak256(\\\"2\\\"))) - 9, // range: -9 - 9\\n      cloudColor: colors[0],\\n      buttonColor: colors[1],\\n      snowAnimOffsetX: int256(PRNG.range(0, 600)) - 300 // range: -300 - 300\\n    });\\n\\n    s_attributes[tokenId] = snowman;\\n  }\\n}\\n\",\"keccak256\":\"0x4fcdd46299d51f913aacad77629725296bd9c90e61537138d7ce9b0c9ded8707\",\"license\":\"MIT\"},\"contracts/libraries/types/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nlibrary DataTypes {\\n  enum AccessoryPosition {\\n    Foreground,\\n    Background\\n  }\\n\\n  struct Accessory {\\n    address _address;\\n    AccessoryPosition position;\\n  }\\n\\n  struct Snowman {\\n    int256 eyeOffsetX;\\n    int256 eyeOffsetY;\\n    string cloudColor;\\n    string buttonColor;\\n    int256 snowAnimOffsetX;\\n  }\\n\\n  struct Hat {\\n    string color;\\n  }\\n\\n  struct Scarf {\\n    string color;\\n  }\\n\\n  struct Belt {\\n    string color;\\n  }\\n}\\n\",\"keccak256\":\"0x314f787fec39584c6426fb083fe708b4cd73b0f9df7bac896ed2b836ebf2fe9b\",\"license\":\"MIT\"},\"contracts/libraries/utils/ColorGen.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport {PRNG} from \\\"./PRNG.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary ColorGen {\\n  using PRNG for uint256;\\n  using Strings for uint256;\\n\\n  bytes16 internal constant ALPHABET = \\\"0123456789abcdef\\\";\\n  uint256 internal constant MIN_RGB_VALUE = 0;\\n  uint256 internal constant MAX_RGB_VALUE = 255;\\n  uint256 internal constant MIN_HSL_VALUE = 0;\\n  uint256 internal constant MAX_HSL_VALUE = 100;\\n  uint256 internal constant MIN_ALPHA = 3;\\n  uint256 internal constant MAX_ALPHA = 10;\\n\\n  function HEX() internal view returns (string memory) {\\n    bytes32 randHash = keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender, address(this)));\\n    bytes3 color = bytes2(randHash[0]) | (bytes2(randHash[1]) >> 8) | (bytes3(randHash[2]) >> 16);\\n    return _formatHEX(color);\\n  }\\n\\n  function HEX(bytes32 seed) internal view returns (string memory) {\\n    bytes32 randHash = keccak256(abi.encodePacked(seed, blockhash(block.number - 1), msg.sender, address(this)));\\n    bytes3 color = bytes2(randHash[0]) | (bytes2(randHash[1]) >> 8) | (bytes3(randHash[2]) >> 16);\\n    return _formatHEX(color);\\n  }\\n\\n  function RGB() internal view returns (string memory) {\\n    uint256[3] memory randNums;\\n\\n    for (uint256 i = 0; i < 3; i++) {\\n      randNums[i] = MIN_RGB_VALUE.range(MAX_RGB_VALUE, bytes32(i));\\n    }\\n\\n    string memory color = _formatRGB(randNums[0], randNums[1], randNums[2]);\\n    return color;\\n  }\\n\\n  function RGB(bytes32 seed) internal view returns (string memory) {\\n    uint256[3] memory randNums;\\n\\n    for (uint256 i = 0; i < 3; i++) {\\n      bytes32 _seed = bytes32(keccak256(abi.encodePacked(seed, i)));\\n      randNums[i] = MIN_RGB_VALUE.range(MAX_RGB_VALUE, _seed);\\n    }\\n\\n    string memory color = _formatRGB(randNums[0], randNums[1], randNums[2]);\\n    return color;\\n  }\\n\\n  function RGBA() internal view returns (string memory) {\\n    uint256[4] memory randNums;\\n\\n    //  rgb\\n    for (uint256 i = 0; i < 3; i++) {\\n      randNums[i] = MIN_RGB_VALUE.range(MAX_RGB_VALUE, bytes32(i));\\n    }\\n    //  alpha\\n    randNums[3] = MIN_ALPHA.range(MAX_ALPHA);\\n\\n    string memory color = _formatRGBA(randNums[0], randNums[1], randNums[2], randNums[3]);\\n    return color;\\n  }\\n\\n  function RGBA(bytes32 seed) internal view returns (string memory) {\\n    uint256[4] memory randNums;\\n\\n    //  rgb\\n    for (uint256 i = 0; i < 3; i++) {\\n      bytes32 _seed = bytes32(keccak256(abi.encodePacked(seed, i)));\\n      randNums[i] = MIN_RGB_VALUE.range(MAX_RGB_VALUE, _seed);\\n    }\\n    //  alpha\\n    randNums[3] = MIN_ALPHA.range(MAX_ALPHA, seed);\\n\\n    string memory color = _formatRGBA(randNums[0], randNums[1], randNums[2], randNums[3]);\\n    return color;\\n  }\\n\\n  function HSL() internal view returns (string memory) {\\n    uint256[3] memory randNums;\\n\\n    for (uint256 i = 0; i < 3; i++) {\\n      randNums[i] = MIN_HSL_VALUE.range(MAX_HSL_VALUE, bytes32(i));\\n    }\\n\\n    string memory color = _formatHSL(randNums[0], randNums[1], randNums[2]);\\n    return color;\\n  }\\n\\n  function HSL(bytes32 seed) internal view returns (string memory) {\\n    uint256[3] memory randNums;\\n\\n    for (uint256 i = 0; i < 3; i++) {\\n      bytes32 _seed = bytes32(keccak256(abi.encodePacked(seed, i)));\\n      randNums[i] = MIN_HSL_VALUE.range(MAX_HSL_VALUE, _seed);\\n    }\\n\\n    string memory color = _formatHSL(randNums[0], randNums[1], randNums[2]);\\n    return color;\\n  }\\n\\n  function HSLA() internal view returns (string memory) {\\n    uint256[4] memory randNums;\\n\\n    for (uint256 i = 0; i < 3; i++) {\\n      randNums[i] = MIN_HSL_VALUE.range(MAX_HSL_VALUE, bytes32(i));\\n    }\\n\\n    randNums[3] = MIN_ALPHA.range(MAX_ALPHA);\\n\\n    string memory color = _formatHSLA(randNums[0], randNums[1], randNums[2], randNums[3]);\\n    return color;\\n  }\\n\\n  function HSLA(bytes32 seed) internal view returns (string memory) {\\n    uint256[4] memory randNums;\\n\\n    for (uint256 i = 0; i < 3; i++) {\\n      bytes32 _seed = bytes32(keccak256(abi.encodePacked(seed, i)));\\n      randNums[i] = MIN_HSL_VALUE.range(MAX_HSL_VALUE, _seed);\\n    }\\n\\n    randNums[3] = MIN_ALPHA.range(MAX_ALPHA, seed);\\n\\n    string memory color = _formatHSLA(randNums[0], randNums[1], randNums[2], randNums[3]);\\n    return color;\\n  }\\n\\n  function _formatHEX(bytes3 value) private pure returns (string memory) {\\n    bytes memory buffer = new bytes(6);\\n    for (uint256 i = 0; i < 3; i++) {\\n      buffer[i * 2 + 1] = ALPHABET[uint8(value[i]) & 0xf];\\n      buffer[i * 2] = ALPHABET[uint8(value[i] >> 4) & 0xf];\\n    }\\n    return string(abi.encodePacked(\\\"#\\\", buffer));\\n  }\\n\\n  function _formatRGB(uint256 r, uint256 g, uint256 b) private pure returns (string memory) {\\n    return string(abi.encodePacked(\\\"rgb(\\\", r.toString(), \\\", \\\", g.toString(), \\\", \\\", b.toString(), \\\")\\\"));\\n  }\\n\\n  function _formatRGBA(uint256 r, uint256 g, uint256 b, uint256 a) private pure returns (string memory) {\\n    if (a < MAX_ALPHA) {\\n      return\\n        string(\\n          abi.encodePacked(\\\"rgba(\\\", r.toString(), \\\", \\\", g.toString(), \\\", \\\", b.toString(), \\\", 0.\\\", a.toString(), \\\")\\\")\\n        );\\n    } else {\\n      return string(abi.encodePacked(\\\"rgba(\\\", r.toString(), \\\", \\\", g.toString(), \\\", \\\", b.toString(), \\\", 1)\\\"));\\n    }\\n  }\\n\\n  function _formatHSL(uint256 h, uint256 s, uint256 l) private pure returns (string memory) {\\n    return string(abi.encodePacked(\\\"hsl(\\\", h.toString(), \\\", \\\", s.toString(), \\\"%, \\\", l.toString(), \\\"%)\\\"));\\n  }\\n\\n  function _formatHSLA(uint256 h, uint256 s, uint256 l, uint256 a) private pure returns (string memory) {\\n    if (a < MAX_ALPHA) {\\n      return\\n        string(\\n          abi.encodePacked(\\\"hsla(\\\", h.toString(), \\\", \\\", s.toString(), \\\"%, \\\", l.toString(), \\\"%, 0.\\\", a.toString(), \\\")\\\")\\n        );\\n    } else {\\n      return string(abi.encodePacked(\\\"hsla(\\\", h.toString(), \\\", \\\", s.toString(), \\\"%, \\\", l.toString(), \\\"%, 1)\\\"));\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x5b62e9605ddb479b8cfa475fb03e2aeb84798e97ce7895bd3cd5107ad83cc91c\",\"license\":\"MIT\"},\"contracts/libraries/utils/PRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nerror PRNG__InvalidRange(uint256 min, uint256 max);\\n\\nlibrary PRNG {\\n  modifier isValidRange(uint256 min, uint256 max) {\\n    if (min >= max) revert PRNG__InvalidRange(min, max);\\n    _;\\n  }\\n\\n  function randomNumber() internal view returns (uint256) {\\n    return\\n      uint256(keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 1), msg.sender, address(this))));\\n  }\\n\\n  function randomNumber(bytes32 seed) internal view returns (uint256) {\\n    return\\n      uint256(\\n        keccak256(abi.encodePacked(seed, block.timestamp, blockhash(block.number - 1), msg.sender, address(this)))\\n      );\\n  }\\n\\n  function range(uint256 min, uint256 max) internal view isValidRange(min, max) returns (uint256) {\\n    uint256 exclusiveMax = (max - min) + 1;\\n    uint256 randNum = randomNumber() % exclusiveMax;\\n\\n    return randNum + min;\\n  }\\n\\n  function range(uint256 min, uint256 max, bytes32 seed) internal view isValidRange(min, max) returns (uint256) {\\n    uint256 exclusiveMax = (max - min) + 1;\\n    uint256 randNum = randomNumber(seed) % exclusiveMax;\\n\\n    return randNum + min;\\n  }\\n}\\n\",\"keccak256\":\"0x702957463338a5bf3fcd29938522997421f25de5974cabfc12ca119200f67479\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001c576109ed908161002282393081602b0152f35b600080fdfe608080604052600436101561001357600080fd5b60003560e01c63391b088d1461002857600080fd5b307f00000000000000000000000000000000000000000000000000000000000000001461066057604036600319011261066057608081610069600093610665565b8281528260208201526060604082015260608082015201526040516040810181811067ffffffffffffffff8211176103df5760405260005b60408110610652575043600019019060005b600281106104d757504382116104c157610128601460405160208101907fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc68252426040820152854060608201523360601b60808201523060601b60948201526088815261011f81610681565b519020066106df565b90610185601460405160208101907fad7c5bef027816a800da1736444fb58a807ef4c9603b7848673f7e3a68eb14a58252426040820152864060608201523360601b60808201523060601b60948201526088815261011f81610681565b92610259602083519301519160405160208101914283524060408201523360601b60608201523060601b6074820152606881526101c181610665565b519020069061012b1982019182136001166104c157604051936101e385610665565b8452602084019485526040840192835260608401526080830152602435600052600435602052604060002092825184555160018401555191825167ffffffffffffffff81116103df576002820154600181811c911680156104b7575b60208210146103bf57601f811161046c575b506020601f821160011461040057819293946000926103f5575b50508160011b916000199060031b1c19161760028201555b6003810191606081015192835167ffffffffffffffff81116103df578154600181811c911680156103d5575b60208210146103bf57601f8111610377575b506020601f82116001146103095790806080949392600496976000926102fe575b50508160011b916000199060031b1c19161790555b0151910155005b0151905038806102e2565b601f198216958360005260206000209660005b81811061035f575096600192849260809796956004999a10610346575b505050811b0190556102f7565b015160001960f88460031b161c19169055388080610339565b8383015189556001909801976020938401930161031c565b826000526020600020601f830160051c810191602084106103b5575b601f0160051c01905b8181106103a957506102c1565b6000815560010161039c565b9091508190610393565b634e487b7160e01b600052602260045260246000fd5b90607f16906102af565b634e487b7160e01b600052604160045260246000fd5b01519050388061026b565b601f198216906002840160005260206000209160005b8181106104545750958360019596971061043b575b505050811b016002820155610283565b015160001960f88460031b161c1916905538808061042b565b9192602060018192868b015181550194019201610416565b600283016000526020600020601f830160051c810191602084106104ad575b601f0160051c01905b8181106104a15750610251565b60008155600101610494565b909150819061048b565b90607f169061023f565b634e487b7160e01b600052601160045260246000fd5b604051906080820182811067ffffffffffffffff8211176103df57604052608036833760005b6003811061059757504384116104c15760076040516020810190838252426040820152864060608201523360601b60808201523060601b60948201526088815261054681610681565b5190201691600383018093116104c1578281610592946060610577940152805190604060208201519101519161071c565b61058182856106ce565b5261058c81846106ce565b506106bf565b6100b3565b60409491939451602081018581528260408301526040825281606081011067ffffffffffffffff6060840111176103df5760608201604052815190204384116104c1576060826080606594019283524260a0820152854060c082015233821b60e082015230821b60f4820152608882820152610614828201610681565b015190200690600481101561063c57610633918160051b8501526106bf565b939290936104fd565b634e487b7160e01b600052603260045260246000fd5b6060828201526020016100a1565b600080fd5b60a0810190811067ffffffffffffffff8211176103df57604052565b60c0810190811067ffffffffffffffff8211176103df57604052565b90601f8019910116810190811067ffffffffffffffff8211176103df57604052565b60001981146104c15760010190565b90600281101561063c5760051b0190565b9060081982019182136001166104c157565b9081519160005b838110610709575050016000815290565b80602080928401015181850152016106f8565b92909190600a8110156107d057916107b760019260056107a56107cd96600361079561076561075f6107596107536107869e61084f565b9a61084f565b9761084f565b9361084f565b9560026040519c8d9a640d0e6d8c2560db1b60208d015260258c01906106f1565b61016160f51b815201906106f1565b6201296160ed1b815201906106f1565b64129610181760d91b815201906106f1565b602960f81b815203601e1981018452018261069d565b90565b506107cd9161081960059260036107956107f861075f6107f26107869a61084f565b9661084f565b926002604051998a97640d0e6d8c2560db1b60208a015260258901906106f1565b64252c20312960d81b815203601a1981018452018261069d565b67ffffffffffffffff81116103df57601f01601f191660200190565b806000917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000808210156109a9575b506d04ee2d6d415b85acef81000000008083101561099a575b50662386f26fc100008083101561098b575b506305f5e1008083101561097c575b506127108083101561096d575b50606482101561095d575b600a80921015610953575b600190816021818601956108e887610833565b966108f6604051988961069d565b808852610905601f1991610833565b01366020890137860101905b61091d575b5050505090565b600019019083906f181899199a1a9b1b9c1cb0b131b232b360811b8282061a83530491821561094e57919082610911565b610916565b91600101916108d5565b91906064600291049101916108ca565b600491939204910191386108bf565b600891939204910191386108b2565b601091939204910191386108a3565b60209193920491019138610891565b60409350810491503861087856fea2646970667358221220cadbe3ce33e197e5b4ae76836219fd8630f058802b3fab8bd5fedc9e9f7f11f864736f6c63430008120033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b60003560e01c63391b088d1461002857600080fd5b307f00000000000000000000000000000000000000000000000000000000000000001461066057604036600319011261066057608081610069600093610665565b8281528260208201526060604082015260608082015201526040516040810181811067ffffffffffffffff8211176103df5760405260005b60408110610652575043600019019060005b600281106104d757504382116104c157610128601460405160208101907fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc68252426040820152854060608201523360601b60808201523060601b60948201526088815261011f81610681565b519020066106df565b90610185601460405160208101907fad7c5bef027816a800da1736444fb58a807ef4c9603b7848673f7e3a68eb14a58252426040820152864060608201523360601b60808201523060601b60948201526088815261011f81610681565b92610259602083519301519160405160208101914283524060408201523360601b60608201523060601b6074820152606881526101c181610665565b519020069061012b1982019182136001166104c157604051936101e385610665565b8452602084019485526040840192835260608401526080830152602435600052600435602052604060002092825184555160018401555191825167ffffffffffffffff81116103df576002820154600181811c911680156104b7575b60208210146103bf57601f811161046c575b506020601f821160011461040057819293946000926103f5575b50508160011b916000199060031b1c19161760028201555b6003810191606081015192835167ffffffffffffffff81116103df578154600181811c911680156103d5575b60208210146103bf57601f8111610377575b506020601f82116001146103095790806080949392600496976000926102fe575b50508160011b916000199060031b1c19161790555b0151910155005b0151905038806102e2565b601f198216958360005260206000209660005b81811061035f575096600192849260809796956004999a10610346575b505050811b0190556102f7565b015160001960f88460031b161c19169055388080610339565b8383015189556001909801976020938401930161031c565b826000526020600020601f830160051c810191602084106103b5575b601f0160051c01905b8181106103a957506102c1565b6000815560010161039c565b9091508190610393565b634e487b7160e01b600052602260045260246000fd5b90607f16906102af565b634e487b7160e01b600052604160045260246000fd5b01519050388061026b565b601f198216906002840160005260206000209160005b8181106104545750958360019596971061043b575b505050811b016002820155610283565b015160001960f88460031b161c1916905538808061042b565b9192602060018192868b015181550194019201610416565b600283016000526020600020601f830160051c810191602084106104ad575b601f0160051c01905b8181106104a15750610251565b60008155600101610494565b909150819061048b565b90607f169061023f565b634e487b7160e01b600052601160045260246000fd5b604051906080820182811067ffffffffffffffff8211176103df57604052608036833760005b6003811061059757504384116104c15760076040516020810190838252426040820152864060608201523360601b60808201523060601b60948201526088815261054681610681565b5190201691600383018093116104c1578281610592946060610577940152805190604060208201519101519161071c565b61058182856106ce565b5261058c81846106ce565b506106bf565b6100b3565b60409491939451602081018581528260408301526040825281606081011067ffffffffffffffff6060840111176103df5760608201604052815190204384116104c1576060826080606594019283524260a0820152854060c082015233821b60e082015230821b60f4820152608882820152610614828201610681565b015190200690600481101561063c57610633918160051b8501526106bf565b939290936104fd565b634e487b7160e01b600052603260045260246000fd5b6060828201526020016100a1565b600080fd5b60a0810190811067ffffffffffffffff8211176103df57604052565b60c0810190811067ffffffffffffffff8211176103df57604052565b90601f8019910116810190811067ffffffffffffffff8211176103df57604052565b60001981146104c15760010190565b90600281101561063c5760051b0190565b9060081982019182136001166104c157565b9081519160005b838110610709575050016000815290565b80602080928401015181850152016106f8565b92909190600a8110156107d057916107b760019260056107a56107cd96600361079561076561075f6107596107536107869e61084f565b9a61084f565b9761084f565b9361084f565b9560026040519c8d9a640d0e6d8c2560db1b60208d015260258c01906106f1565b61016160f51b815201906106f1565b6201296160ed1b815201906106f1565b64129610181760d91b815201906106f1565b602960f81b815203601e1981018452018261069d565b90565b506107cd9161081960059260036107956107f861075f6107f26107869a61084f565b9661084f565b926002604051998a97640d0e6d8c2560db1b60208a015260258901906106f1565b64252c20312960d81b815203601a1981018452018261069d565b67ffffffffffffffff81116103df57601f01601f191660200190565b806000917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000808210156109a9575b506d04ee2d6d415b85acef81000000008083101561099a575b50662386f26fc100008083101561098b575b506305f5e1008083101561097c575b506127108083101561096d575b50606482101561095d575b600a80921015610953575b600190816021818601956108e887610833565b966108f6604051988961069d565b808852610905601f1991610833565b01366020890137860101905b61091d575b5050505090565b600019019083906f181899199a1a9b1b9c1cb0b131b232b360811b8282061a83530491821561094e57919082610911565b610916565b91600101916108d5565b91906064600291049101916108ca565b600491939204910191386108bf565b600891939204910191386108b2565b601091939204910191386108a3565b60209193920491019138610891565b60409350810491503861087856fea2646970667358221220cadbe3ce33e197e5b4ae76836219fd8630f058802b3fab8bd5fedc9e9f7f11f864736f6c63430008120033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}